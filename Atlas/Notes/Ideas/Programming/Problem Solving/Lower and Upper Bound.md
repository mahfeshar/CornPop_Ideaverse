## Lower and Upper Bound
لو مش عايز أجيب الرقم نفسه بس عايز أجيب الرقم الأكبر منه أو اللي قده
هنشرح على الـ Lower Bound

![[Pasted image 20240901175653.png]]
مثلًا في المثال دا عايز أجيب أول رقم أكبر من أو يساوي الـ 18
فأنا هنا هيبقا عندي إما الرقم دا أصغر منه (Invalid) أو أكبر منه أو يساويه (Valid)

فكدا معنديش غير احتمالين يعني لو طبقت نفس اللي فوق:
- لقيت الرقم أصغر من الرقم المطلوب يبقا كدا كل اللي قبله Invalid فممكن أرميه وحتى نفسه مينفعش
- لقيت الرقم أكبر من الرقم المطلوب يبقا كل اللي بعده برضو مش عايزه لأن الرقم اللي انا عليه دا ممكن يبقا هو الـ Upper أو الـ Upper أصغر منه  (هو نفسه ينفع)

نكمل المثال هنحط البوينتر في النص عند الـ 17 ونشوف ينفع ولا لا فهو أقل فمينفعش فأنقل الـ Pointer بعده

![[Pasted image 20240901180020.png]]
وهكذا

### Edge case
- لو كل الأرقام أصغر منها ومفيش ولا رقم ينفع فعندي حلين:
	- إما ان الاتنين بوينترز يبقوا على بعض وبرضو إن الرقم Invalid بعمل check وبقول ان مفيش
	- إني أعمل فالأخر رقم وهمي مش عندي اسمه inf ولو وصلتله يبقا كدا مفيش ولا رقم ينفع

![[Pasted image 20240901180848.png]]

## Build-in Function
Lower ⇒ بترجع رقم أكبر من أو يساوي الرقم اللي هدور على (x >= y)

upper ⇒ بيرجع رقم أكبر من اللي بدور عليه (x > y)

بيرجع iterator

لو الرقم الأكبر من دا مش موجود في ال array هيرجع garbage value
انما لو الرقم اللي بدور عليه مش موجود عادي

---

فيه جوا ال set, vector, map أي حاجة فيها iterator جواه ال functions دي
- لازم الحاجة اللي هستخدمهم عليها تكون **مترتبة**

```cpp
int myints[] = {10,20,30,30,20,10,10,20};
vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20

sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

vector<int>::iterator low,up;
low=std::lower_bound (v.begin(), v.end(), 20); //      ^
up= std::upper_bound (v.begin(), v.end(), 20); //               ^
```